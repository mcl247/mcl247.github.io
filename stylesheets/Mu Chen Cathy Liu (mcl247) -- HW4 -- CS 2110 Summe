Mu Chen Cathy Liu (mcl247) -- HW4 -- CS 2110 Summer 2017 

—————————————————————————————————
Question 1: QueueFunctionalities.java 

First, I have a People class with the fields string name and int priority. The name is used to identify the person and the priority can serve both as the ID and the priority/VIP status identifier. The People class has two contains method: by name and by ID/priority. The containsName method returns true if name equals string input and the containsID method returns true if ID equals int input. The toString method prints out the People by name and priority. 

Then, I have a Priority Queue class with a People array called storage, and int length, size, and back. Also, I have a contains method and a contains2 method. In my contains methods, I loop through the storage array of people and call the containsName method (from People's class) at each index to search through the people storage by name. Similarly, I loop thorugh the storage array and call the containsID method at each index to search through the people storage by priority/ID. The insert method inserts new Peoples according to the user input priority. The lower the number, the higher the priority. Next, I have two remove methods: one for removing by index (corresponds to the priority), and one for removing just the highest priority person. Other methods include clear, is empty, is full, and size. 

My Priority Queue Test class has a main method that tests my program by user input. When the program is ran, it firsts asks for the size of the queue since I implemented my queue with an array. Then, a menu will pop up with 7 different operations that my program can perform: pushing, popping, inserting, removing by priority, removing by specified index, search by name, and search by ID/priority. 

Pushing and popping works like a normal queue. The priority number will just serve as an id for the person. However, if pushing is used instead of inserting by index, only popping would work normally and not removing by highest priority since the person is pushed onto the queue without inserting into specific order. Same goes for popping. When "inserting a person" is chosen, user must first input a name, then an int (can be separated by a space or name, press enter, then int). E.g.: Cathy 1. This sepcifies the order of how each person will be inserted into the queue (inserting to a specific spot). Therefore, despite the order inwhich I inputted the People, the priority determines which spot each People will be at. Inserting can also be interpreted as pushing like a normal queue like "Cathy 1", "Bob 2" which would make Cathy in the back of the line. If remove method is called, Cathy would be removed first like a normal queue. Next, removing by priority is basically popping off the last index (with the highest priority). Removing by index is implemented by user input. So if I want to remove Bob, I would enter "2". Next, I have searching by name implemented by my contains method. User inputs the name to be searched and if found, a message will display. Similarly, search by ID searches the priority of the People. So if I want to find Cathy, I would enter the int 1. A message will display when found. 

PS: I tried implementing a JUnit test but am still not too familiar with it and ran out of time. But will go to office hours to learn it more/try implementing it for sure next hw assignment. 

—————————————————————————————————
Question 2: DirectedGraph.java 

First, I created a graph class called DirectedGraph.java which holds people and the people are connected to each other directionally. 

My graph is populated by reading from the textfiles I've created. The file’s first line is an int number that allows the adjacency list array size to be set according to the number of People (vertices). Then, People and Neighbors are populated.fter reading from the file and setting the array size of the adjacency list, the scanner reads the vertices (people) in a loop, and each time a people object is created with the person’s name, and null field for neighbor list. Then the edges (neighbors) are scanned. In order for the neighbor to be added to each linked list, the corresponding vertex numbers need to be known. This is implemented with the nameIndex method where people objects in the adjacency list array is compared to the target name. The current index in the array is returned if data is valid. If it is a match, then person 2 is added as a neighbor to the front of person 1’s adjacency list. Output is then printed.

I used my bfs search to allow my nodes to "make friends by leveraging the currently existing friendships". In my search, I start with the first person with the index of 0, and specified an end index of 9 (10th person). As the first and the tenth person aren't friends already, I want to find a path from the first to the tenth and allow the two people to be friends through leveraging the existing friendships. 

I added a karma point field called "cost" tied to each Node and karma points vary between different people (Nodes). Once a path is traversed through between person one and person ten, the karma points of all the people who created the path (led from first to tenth person) decrease by one. The path from person one to person ten is printed along with the karma points and the end karma points of each friend leveraged. Then, the new friendship is created between person one and person ten and printed. Then, I did a calculation of the number of points expended in order to make the friendship. 

"friends2.txt" is a general graph example of how I implemented everything. My algorithm finds paths between the first person (Cathy) to the 10th person (Kristin) by leveraging the friends of friends. The decreased karma points for each person is printed and the new friendship between Cathy and Kristin are established. My interpretation for the optimal path is the least number of karma points expended. As I have a count for the number of karma points expended for each path, the optimal path is determined by the least points.

As the continual leveraging of the same friend incurs a cost, I have a file called "friends3.txt" that tests out what happens when a friend has 0 karma points and cannot introduce new friends. When 0 karma points is reached, an error message displays and the intended new friendship cannot be made and the program stops. 

"friends4.txt" shows finding clusters. I defined finding a cluster being a Node that has 5 or more outgoing edges. From the cluster central spot, the other nodes are more scattered compared to the cluster. Therefore, when detected from the graph in this file, a message is printed showing that a cluster is found. 